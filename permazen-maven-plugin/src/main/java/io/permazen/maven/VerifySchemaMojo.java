
/*
 * Copyright (C) 2015 Archie L. Cobbs. All rights reserved.
 */

package io.permazen.maven;

import io.permazen.Permazen;
import io.permazen.core.SchemaMismatchException;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;

import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;

/**
 * Verify the Permazen schema auto-generated from user-supplied model classes.
 *
 * <p>
 * This goal verifies that the Permazen schema can be successfully auto-generated from user-supplied model classes
 * and that the generated schema matches what is expected.
 *
 * <p>
 * It can also check that the schema will not generate any {@link SchemaMismatchException}s at runtime due to conflicts
 * with older schemas that may be already present in a database. Note, these exceptions can only occur when explicit
 * storage ID's are used.
 *
 * <p>
 * The expected schema check is enabled by providing an expected schema XML file. This file should correspond to the
 * project's current schema. It will be compared with the schema that is actually generated from the model Java classes.
 * The current expected schema XML file location is configured by {@code <expectedSchemaFile>};
 *
 * <p>
 * To check for conflicts with other schema versions, supply XML files containing any old schema versions in the old schema
 * files directory. All files ending in {@code .xml} found anywhere under this directory are checked for conflicts with
 * the current schema version. The old schema XML files directory is configured by {@code <oldSchemasDirectory>}.
 *
 * <p>
 * If this goal fails due to the schema not matching what's expected:
 * <ul>
 *  <li>The old expected schema XML file should be deleted (or moved into the old schemas directory);</li>
 *  <li>the new expected schema XML file (found in the location configured by {@code <actualSchemaFile>})
 *      should be copied to the current expected schema XML file.</li>
 * </ul>
 *
 * <p>
 * If this goal fails due to an incompatibility of the second type, you must adjust your model classes to make
 * them compatible again by, for example, changing field names and/or explicit storage ID assignments.
 */
@Mojo(name = "verify",
  defaultPhase = LifecyclePhase.PROCESS_CLASSES,
  requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME,
  threadSafe = true)
public class VerifySchemaMojo extends AbstractMainSchemaMojo {

    public static final String OLD_SCHEMAS_DEFAULT = GenerateSchemaMojo.PERMAZEN_DIRECTORY_DEFAULT + "/old";

    /**
     * The schema XML file that contains the expected current schema.
     */
    @Parameter(defaultValue = GenerateSchemaMojo.EXPECTED_SCHEMA_DEFAULT, property = "expectedSchemaFile")
    private File expectedSchemaFile;

    /**
     * The schema XML file generated by this goal that contains the actual current schema.
     */
    @Parameter(defaultValue = "${project.build.directory}/actual-permazen-schema.xml", property = "actualSchemaFile")
    private File actualSchemaFile;

    /**
     * Whether to automatically generate the expected schema file if it does not already exist.
     *
     * <p>
     * If changed to {@code false}, this goal will fail instead and leave the actual schema XML file
     * in the {@code <actualSchemaFile>} location if the file doesn't exist.
     */
    @Parameter(defaultValue = "true")
    private boolean autoGenerate;

    /**
     * The directory containing old schemas still in use in any existing databases.
     */
    @Parameter(defaultValue = VerifySchemaMojo.OLD_SCHEMAS_DEFAULT, property = "oldSchemasDirectory")
    private File oldSchemasDirectory;

    @Override
    protected void execute(Permazen jdb) throws MojoExecutionException, MojoFailureException {

        // Handle the case where the expected schema file doesn't exist
        if (!this.expectedSchemaFile.exists()) {
            if (!this.autoGenerate)
                throw new MojoFailureException("expected schema file " + expectedSchemaFile + " does not exist");
            this.generate(jdb.getSchemaModel(), this.expectedSchemaFile);
            return;
        }

        // Verify actual vs. expected
        if (!this.verify(jdb.getSchemaModel(), this.expectedSchemaFile)) {
            this.getLog().info("Recommended actions to take:\n"
              + "  (a) If no schema change was intended, undo whatever Java model class change(s) caused the schema difference.\n"
              + "  (b) Otherwise, move " + this.actualSchemaFile + " to " + this.expectedSchemaFile);
        }

        // Gather old schema files
        final ArrayList<File> oldSchemaFiles = new ArrayList<>();
        if (this.oldSchemasDirectory.exists()) {
            try {
                Files.walkFileTree(this.oldSchemasDirectory.toPath(), new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
                        if (path.getNameCount() != 0 && path.getName(path.getNameCount() - 1).toString().endsWith(".xml"))
                            oldSchemaFiles.add(path.toFile());
                        return FileVisitResult.CONTINUE;
                    }
                });
            } catch (IOException e) {
                throw new MojoExecutionException("error walking output directory hierarchy", e);
            }
        }

        // Verify compatibility with old schemas
        if (!this.verify(jdb, oldSchemaFiles.iterator()))
            throw new MojoFailureException("current schema conflicts with one or more old schemas");
    }
}
