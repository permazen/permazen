
/*
 * Copyright (C) 2015 Archie L. Cobbs. All rights reserved.
 */

package io.permazen.annotation;

import io.permazen.Counter;
import io.permazen.Permazen;
import io.permazen.PermazenObject;
import io.permazen.ReferencePath;
import io.permazen.UpgradeConversionPolicy;
import io.permazen.schema.SchemaId;
import io.permazen.schema.SchemaModel;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Java annotation for Java classes that represent Permazen database object types.
 *
 * <p>
 * Model classes may be POJO's, {@code abstract} classes, or interfaces, and the Java bean getter methods therein define database
 * fields; Permazen generates concrete subclasses of each model class at runtime.
 * Model classes must have a zero-arg constructor with at least {@code protected} access.
 *
 * <p>
 * The following annotations on the getter methods of a {@link PermazenType &#64;PermazenType}-annotated class
 * configure database fields:
 * <ul>
 *  <li>{@link PermazenField &#64;PermazenField} - defines a simple value, reference, or {@link Counter} field
 *  <li>{@link PermazenSetField &#64;PermazenSetField} - defines a {@link java.util.NavigableSet} field
 *  <li>{@link PermazenListField &#64;PermazenListField} - defines a {@link java.util.List} field
 *  <li>{@link PermazenMapField &#64;PermazenMapField} - defines a {@link java.util.NavigableMap} field
 * </ul>
 *
 * <p>
 * {@linkplain #autogenFields By default}, database fields are created automatically for all abstract getter methods,
 * so no annotations are required. To override the defaults, or define database fields for non-abstract getter methods,
 * add the appropriate {@link PermazenField &#64;PermazenField}, {@link PermazenSetField &#64;PermazenSetField},
 * {@link PermazenListField &#64;PermazenListField}, or {@link PermazenMapField &#64;PermazenMapField} annotation.
 *
 * <p>
 * These annotations are also supported on the methods in a {@link PermazenType &#64;PermazenType}-annotated class:
 *
 * <ul>
 *  <li>{@link OnChange &#64;OnChange} - annotates a method to be invoked when some field (possibly seen through
 *      a path of references) changes
 *  <li>{@link OnCreate &#64;OnCreate} - annotates a method to be invoked just after object creation
 *  <li>{@link OnDelete &#64;OnDelete} - annotates a method to be invoked just prior to object deletion
 *  <li>{@link OnValidate &#64;OnValidate} - annotates a method to be invoked whenever the object is (re)validated
 *  <li>{@link OnSchemaChange &#64;OnSchemaChange} - annotates a method to be invoked when the object's schema changes
 *  <li>{@link ReferencePath &#64;ReferencePath} - annotates a method returning objects found by traversing a
 *      path of reference fields
 * </ul>
 *
 * <p>
 * Annotations are "inherited", meaning they may be present on any overridden supertype method, including methods in superclasses
 * and superinterfaces (whether or not annotated with {@link PermazenType &#64;PermazenType}).
 *
 * <p><b>{@link PermazenObject} interface</b></p>
 *
 * <p>
 * The subclass of any {@link PermazenType &#64;PermazenType}-annotated model class that is generated by {@link Permazen}
 * will implement {@link PermazenObject}, so the (abstract) model classes may be declared that way.
 *
 * <p><b>Indexing</b></p>
 *
 * <p>
 * Indexes on simple fields and collection fields are declared via {@link PermazenField#indexed}.
 *
 * <p>
 * Composite indexes are declared by annotating any supertype of a {@link PermazenType &#64;PermazenType}-annotated class
 * with one or more {@link PermazenCompositeIndex &#64;PermazenCompositeIndex} annotations.
 *
 * <p><b>Meta-Annotations</b></p>
 *
 * <p>
 * This annotation may be configured indirectly as a Spring
 * <a href="https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.html#beans-meta-annotations">meta-annotation</a>
 * when {@code spring-core} is on the classpath.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.ANNOTATION_TYPE, ElementType.TYPE })
@Documented
public @interface PermazenType {

    /**
     * The name of this object type.
     *
     * <p>
     * If equal to the empty string (default value),
     * the {@linkplain Class#getSimpleName simple name} of the annotated Java class is used.
     *
     * @return object type name
     */
    String name() default "";

    /**
     * Storage ID for this object type.
     *
     * <p>
     * Normally this value is left as zero, in which case a value will be automatically assigned.
     *
     * <p>
     * Otherwise, the value should be positive and unique within the schema.
     *
     * @return this object type's storage ID, or zero for automatic assignment
     */
    int storageId() default 0;

    /**
     * Whether to automatically generate database fields from un-annotated abstract Java bean methods.
     *
     * <p>
     * If true, database fields will be auto-generated corresponding to all <b>abstract</b> bean property getter methods,
     * even if there is no {@link PermazenField &#64;PermazenField}, {@link PermazenSetField &#64;PermazenSetField},
     * {@link PermazenListField &#64;PermazenListField}, or {@link PermazenMapField &#64;PermazenMapField} annotation.
     * Note <i>this includes superclass and interface methods</i>. Methods must be either {@code public} or
     * {@code protected}. In the case of simple fields, there must also be a corresponding setter method.
     *
     * <p>
     * Getter methods with return type assignable to {@link java.util.Set}, {@link java.util.List}, and {@link java.util.Map}
     * will cause the corresponding collection fields to be created; other getter/setter method pairs will cause
     * the corresponding simple fields to be generated.
     *
     * <p>
     * A {@link PermazenTransient &#64;PermazenTransient} annotation on the getter method, or any overridden superclass method,
     * disables this auto-generation for that particular method (this is only useful when applied to non-abstract
     * methods, and therefore when {@link #autogenNonAbstract} is true: if applied to any abstract methods,
     * the auto-generated database subclass wouldn't be instantiable at runtime).
     *
     * @return whether to auto-generate fields from abstract methods
     * @see #autogenNonAbstract
     */
    boolean autogenFields() default true;

    /**
     * Whether to automatically generate database fields even from non-abstract Java bean methods.
     *
     * <p>
     * If {@link #autogenFields} is false, this property is ignored. Otherwise, database fields will be auto-generated
     * corresponding to all bean property getter methods, whether or not marked <b>abstract</b>, unless there is
     * a {@link PermazenTransient &#64;PermazenTransient} annotation.
     *
     * @return whether to auto-generate fields from non-abstract methods when {@link #autogenFields} is true
     * @see #autogenFields
     * @see PermazenTransient
     */
    boolean autogenNonAbstract() default false;

    /**
     * Configure the default for the {@link PermazenField#allowDeleted &#64;PermazenField.allowDeleted()} property
     * for auto-generated reference fields.
     *
     * <p>
     * If {@link #autogenFields} is false, this property is ignored. Otherwise, if this property is true,
     * any auto-generated reference fields will allow assignment to deleted objects in normal transactions.
     * In other words, they will behave as if they had a {@link PermazenField &#64;PermazenField} annotation with
     * {@link PermazenField#allowDeleted} set to true.
     *
     * @return whether auto-generated reference fields should allow assignment to a deleted object in normal transactions
     * @see PermazenField#allowDeleted
     */
    boolean autogenAllowDeleted() default false;

    /**
     * Configure the default for the {@link PermazenField#upgradeConversion &#64;PermazenField.upgradeConversion()} property
     * for auto-generated reference fields.
     *
     * <p>
     * If {@link #autogenFields} is false, this property is ignored. Otherwise, any auto-generated fields will
     * have the specified {@link UpgradeConversionPolicy} applied when upgrading an object from some other schema
     * to the current schema.
     *
     * @return type conversion policy for auto-generated fields
     * @see PermazenField#upgradeConversion
     */
    UpgradeConversionPolicy autogenUpgradeConversion() default UpgradeConversionPolicy.ATTEMPT;

    /**
     * {@link SchemaModel} schema ID hash function salting value.
     *
     * <p>
     * This value is included as input to the hash function used by {@link SchemaModel#getSchemaId}. Therefore,
     * modifying this value will force a schema change, and therefore a subsequent "dummy" migration of all database
     * objects the next time they are accessed, even if there are no other changes to the schema.
     *
     * <p>
     * This can be useful (for example) when you want to force revalidation of all instances of the annotated type
     * on the next access, because revalidation is a side effect of a schema migration.
     *
     * @return schema salt
     * @see PermazenField
     */
    int schemaSalt() default 0;
}
