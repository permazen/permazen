#summary Introduction to JSimpleDB
#labels Featured

== Introduction ==

JSimpleDB is designed to make powerful persistence easy for Java programmers. It does this by relegating the database to the simplest role possible--storing data as key/value pairs--and reimplementing and enhancing all of the usual database supporting features, such as indexes and notifications, in a Java-centric way, and by adding a few new features that traditional databases don't provide at all.

In other words, for the most part JSimpleDB is not trying to create solutions where none existed before. Rather, it's trying to reimplement many of the same, well-tested ideas and algorithms used in traditional databases in a way that is more natural for Java programmers. So convenience and maintainability are primary benefits, but as it happens, new solutions to some problems that traditional databases _don't_ solve for you also become easy and natural.

=== Table of Contents ===

<wiki:toc max_depth="5"/>

== Quick Example ==

JSimpleDB runs on top of a transactional key/value database that you supply. The JSimpleDB code includes adapters for some existing databases, as well as in-memory and flat file key/value stores for testing and prototyping.

JSimpleDB itself is configured entirely using Java annotations. For example:
<code language="java">
@JSimpleClass(storageId = 100)
public abstract class Person implements JObject {
 
    // My age
    @JField(storageId = 101)
    public abstract int getAge();
    public abstract void setAge(int age);
 
    // My friends
    @JSetField(storageId = 102, element = @JField(storageId = 103))
    public abstract Set<Person> getFriends();
}</code>

Of note:
 * We are defining a persistent database object `Person` containing two fields:
   * An `int` field named `age` of type `int`
   * A `Set` field named `friends` with element type `Person`
 * The getter methods for `age` and `friends` may be declared `abstract`
   * JSimpleDB will override these methods in an auto-generated subclass at runtime
   * The generated subclass will implement the `JObject` interface
 * JSimpleDB contains built-in support for sets, lists, and maps
   * You can build virtually anything out of these three collection types
 * There is no setter method for the `friends` set
   * The set will always exist
 * Every Java model class and field (including sub-fields, like the `element` sub-field of `friends`) has a unique *storage ID*
   * Internally, objects and fields are identified by storage ID, not name
   * Storage IDs are used to access (possibly removed) old fields after a schema change (more on that later)

== Accessing Data ==

=== Object Lifecycle ===

So far so good. But how do you create a `Person`? Invoke `create()` on a `JTransaction` object, e.g.:

<code language="java">
    // Create a Person
    public static Person create() {
        return JTransaction.getCurrent().create(Person.class);
    }</code>

`JTransaction` represents a JSimpleDB transaction. The `JTransaction` associated with the current thread is available from the static method `JTransaction.getCurrent()`.

All state associated with JSimpleDB objects lives in the `JTransaction`. The model objects themselves are stateless, except for their internal object ID. When you access a field of a model object, you are implicitly accessing that field's value in the `JTransaction` associated with the current thread. If there is no such `JTransaction`, an `IllegalStateException` is thrown.

Java model objects do not change from transaction to transaction like with JPA. You will get, and can use, the same `Person` object over and over again in multiple transactions. Of course, the person's fields may have different values in different transactions.

If you try to access a `Person` object in a new transaction when that `Person` has been deleted in some earlier committed transaction, you get a `DeletedObjectException`. You can check for this condition via `JObject.exists()`, and (if need be) recreate the object (with all fields reinitialized) via `JObject.recreate()`.

To get all `Person`s:

<code language="java">
    // Get all people
    public static Set<Person> getAll() {
        return JTransaction.getCurrent().getAll(Person.class);
    }</code>

How do you delete a `Person`?

<code language="java">
    person.delete();</code>

Alternately, you can say:

<code language="java">
    JTransaction.getCurrent().delete(person);</code>

The two are equivalent.

The `exists()`, `delete()`, and `recreate()` methods are part of the `JObject` interface, which all generated model subclasses implement. Your classes don't have to to be declared to implement `JObject`, but life is a little easier if they are.

=== Delete Cascade ===

JSimpleDB provides an equivalent of SQL `ON DELETE ...` for reference fields. This applies to the situation where an object is deleted, but that object still has one or more other objects referencing it.

You have four choices, represented by the constants in the `DeleteAction` enum class:

 * `EXCEPTION` - Disallow deletion of such an object; instead, throw `ReferencedObjectException`.
 * `UNREFERENCE` - Set all references to the object to null (in the case of simple reference fields) or remove the corresponding collection entry (in the case of sets and lists) or key/value entry (in the case of maps).
 * `DELETE` - Delete all objects referring to the deleted object, repeating recursively as necessary (cycles in the reference graph are handled properly).
 * `NOTHING` - Do nothing; subsequent attempts to dereference the deleted object will result in a `DeletedObjectException`.

The default value is `EXCEPTION`.

You can be guaranteed to never see any `DeletedObjectException`s if you adhere to the following:
 # Avoid configuring reference fields with `DeleteAction.NOTHING`
 # Always check `exists()` before using a Java model object that has been brought in from outside the transaction

=== Indexes ===

Given the above `Person` class, if you wanted to calculate whether any `Person` having a specific age existed, you would have to write this code:
<code language="java">
    public boolean existsPersonOfAge(int age) {
        for (Person person : Person.getAll()) {
            if (person.getAge() == age)
                return true;
        }
        return false;
    }</code>

Having to write that code is a _good_ thing: JSimpleDB is exposing the underlying performance reality and forcing you to confront the fact that the cost of calculating this function is an iteration over every `Person` in the database. With large database, that could be impractical.

This is of course the perfect situation for an *index* on the `age` field. Here we add `indexed = true` to the `@JField` annotation:

<code language="java">
    // My age - now indexed!
    @JField(storageId = 101, indexed = true)
    public abstract int getAge();
    public abstract void setAge(int age);</code>

To read that index, you just declare an abstract method annotated with `@IndexQuery`:

<code language="java">
    @IndexQuery("age")
    public abstract NavigableMap<Integer, NavigableSet<Person>> queryPersonAges();</code>

In JSimpleDB, an index is a mapping from field value to the set of objects having that value in the field.

Now we can rewrite our `existsPersonOfAge()` method:

<code language="java">
    public boolean existsPersonOfAge(int age) {
        return this.queryPersonAges().containsKey(age);
    }</code>

Since the mapping is a `NavigableMap`, you can efficiently find the minimum or maximum value, created a restricted range of values, iterate values in forward or reverse order, etc.

<code language="java">
    public int getMaximumAge() {
        NavigableMap<Integer, NavigableSet<Person>> index = this.queryPersonAges();
        return !index.isEmpty() ? index.lastKey() : -1;
    }</code>

You may be wondering what sort order applies to `Person`. JSimpleDB sorts database objects by their type (i.e., Java class), and then by their unique object ID (the object ID is available via `JObject.getObjId()`). Object IDs are opaque 64-bit values. Newly created objects get a randomly generated value (this avoids distributed database contention that would occur with an auto-increment counter).

The astute reader may notice that `existsPersonOfAge()` and `getMaximumAge()` should really be a static methods, because there's nothing about them that is specific to one `Person`. And that is correct; however, you can't override static methods, so the method has to be an instance method for JSimpleDB to generate a subclass implementation. If you really wanted a static method, you could do this:

<code language="java">
    @SuppressWarnings("unchecked")
    public static boolean getMaximumAge() {
        NavigableMap<Integer, NavigableSet<Person>> index
          = (NavigableMap<Integer, NavigableSet<Person>>)JTransaction.getCurrent().querySimpleField(101);
        return JTransaction.getCurrent().querySimpleField(101).containsKey(age);
    }</code>

but that's rather ugly. A cleaner option is to define a singleton class `Indexes` containing all of your index query methods.

==== Complex Field Indexes ====

You can also index the `element` sub-field of a `Set` or `List`, or the `key` or `value` sub-field of a `Map`. For example:

<code language="java">
@JSimpleClass(storageId = 200)
public abstract class Student implements JObject {
 
    @JSetField(storageId = 201,
      element = @JField(storageId = 202, indexed = true)
    public abstract Set<LectureClass> getLectureClasses();
 
    @JListField(storageId = 203,
      element = @JField(storageId = 204, indexed = true)
    public abstract List<Teacher> getTeacherRankings();
 
    @JMapField(storageId = 205,
      key = @JField(storageId = 206, indexed = true)
      value = @JField(storageId = 207, indexed = true)
    public abstract Map<Test, Float> getTestScores();
 
    @IndexQuery("lectureClasses.element")
    public abstract NavigableMap<LectureClass, NavigableSet<Student>> queryStudentsByLectureClass();
 
    @IndexQuery("teacherRankings.element")
    public abstract NavigableMap<Teacher, NavigableSet<Student>> queryStudentsByRankedTeacher();
 
    @IndexQuery("testScores.key")
    public abstract NavigableMap<Test, NavigableSet<Student>> queryStudentsByTest();
 
    @IndexQuery("testScores.value")
    public abstract NavigableMap<Float, NavigableSet<Student>> queryStudentsByTestScore();
}</code>

In JSimpleDB, reference fields are always indexed (analogous to SQL, where an index is required for foreign key constraints). So in the above example, setting `indexed = true` is redundant for `lectureClasses`, `teacherRankings`, and `testScores.key`. 

Indexes are a perfect way to providing Java access to both sides of a one-to-many, many-to-one, or many-to-many relationship, without there having to actually be any redundant information: you just query the index for the "inverse" side of the relationship. Contrast with JPA, where it's possible for e.g., `parent.getChildren()` and `child.getParent()` to get out of sync.

==== Complex Field Indexes (Advanced) ====

In the case of `List` and `Map`, you also have the option of returning not just the set of objects having the indexed value, but also their position in the list (for `List`) or corresponding value or key (for `Map`):

<code language="java">
@JSimpleClass(storageId = 200)
public abstract class Student implements JObject {
 
    @IndexQuery("teacherRankings.element")
    public abstract NavigableMap<Teacher, NavigableSet<ListIndexEntry<Student>>> queryStudentsByRankedTeacherWithRank();
 
    @IndexQuery("testScores.key")
    public abstract NavigableMap<Test, NavigableSet<MapKeyIndexEntry<Student, Float>>>
      queryStudentsByTestWithScore();
 
    @IndexQuery("testScores.value")
    public abstract NavigableMap<Float, NavigableSet<MapValueIndexEntry<Student, Test>>>
      queryStudentsByTestScoreWithTest();
}</code>

So while `queryStudentsByRankedTeacher().get(teacher)` returns all students who ranked `teacher`, `queryStudentsByRankedTeacherWithRank().get(teacher)` returns all students who ranked `teacher` along with the teacher's rank.

Similarly, while `queryStudentsByTest().get(test)` returns all students who took `test`, `queryStudentsByTestWithScore().get(test)` returns all students who took `test` along with their scores on the test; and
while `queryStudentsByTestScore().get(95.0f)` returns all students who got a `95` on some test, `queryStudentsByTestScoreWithTest().get(95.0f)` returns all students who got a `95` on some test along with the test on which that score was achieved.

=== Joins ===

Back to our indexed `age` field, now suppose the question you need to frequently answer is not whether any person exists of a specific age, but whether a specifc `Person` has any _friend_ of a specific age.

We just need to somehow intersect the set of that `Person`'s friends with the set of people of a specified age. This is the equivalent of an SQL `INNER JOIN`.

First we need to declare `friends` as a `NavigableSet` (which is what it really is):

<code language="java">
    // My friends
    @JSetField(storageId = 102, element = @JField(storageId = 103))
    public abstract NavigableSet<Person> getFriends();</code>

Then we just do the "join" via set intersection:

<code language="java">
    public boolean existsFriendOfAge(int age) {
        NavigableSet<Person> peopleOfAge = this.queryPersonAges().get(age);
        return peopleOfAge != null && !NavigableSets.intersect(peopleOfAge, this.getFriends()).isEmpty();
    }</code>

The `NavigableSets` utility class provides efficient methods for set intersection, union, and difference. Of course, the sets must have comparable elements, and in particular, a consistent sort order for those elements (which is what allows the intersection operation to be efficient). JSimpleDB provides (and verifies) this consistent ordering for you.

=== Reference Inversion ===

In JSimpleDB reference fields, including sub-fields of a collection field, are always indexed. Therefore, unlike in normal Java programming, we can efficiently determine what objects (if any) refer to a given object:

<code language="java">
    @IndexQuery("friends.element")
    abstract NavigableMap<Person, NavigableSet<Person>> queryFriends();
 
    // Who considers me a friend?
    public Set<Person> whoConsidersMeAFriend() {
        return this.queryFriends().get(this);
    }</code>

More generally, we can even determine what objects refer to a given object indirectly, through an arbitrary sequence of reference fields. Such a sequence is called a *reference path*, and JSimpleDB exposes this functionality via `JTransaction.invertReferencePath()`:

<code language="java">
    // Who considers me a friend?
    public Set<Person> whoConsidersMeAFriend() {
        return JTransaction.getCurrent().invertReferencePath(Person.class,
          "friend", Collections.singleton(this));
    }
 
    // Who considers any of my friends a friend of a friend (possibly someone other than me)?
    public Set<Person> whoConsidersAnyOfMyFriendsAFriendOfAFriend() {
        return JTransaction.getCurrent().invertReferencePath(Person.class,
          "friend.friend", this.getFriends());
    }</code>

A reference path is simply a chain of reference fields via which one can hop through the graph defined by objects (nodes) and references (edges). Following a reference path in the forward direction is what one normally does in Java. JSimpleDB allows you to also invert reference paths.

When inverting reference paths, JSimpleDB eliminates duplicates (caused by multiple routes to the same destination) as soon as possible. However, there's no magic surrounding how reference paths are followed. If you're not careful, you can create a combinatorial explosion.

Reference paths are also the basis of the powerful `@OnChange` annotation, described below.

== Indexing and Detecting Changes ==

=== Indexing in the General Sense ===

A database _index_ is just a special case of _derived information_ that is kept up to date automatically for you by the database. The key benefits of using database indexes are:
 * Much better performance - usually constant time queries
 * The database keeps the derived information up-to-date automatically
 * The database hides all the implementation details, keeping your application logic clean

With JSimpleDB you can easily build your own arbitrary indexes, based on any derived information, that also satisfy these criteria.

Traditionally, in general this is hard part because it means tracking down all the places in your code that could possibly modify the information from which your index is derived and adding hooks in all those places. JSimpleDB makes solving this problem much easier.

With traditional databases, sometimes you can make it work when the information is all contained in one object: then you can add intercept/update code into the setter methods of all the fields that affect the derived information. This extra code effectively serves as a trap for change notification, where it then updates the derived information.

Or if you're lucky, your derived information matches an SQL built-in aggregate function like `MAX()` for which SQL databases often have built-in functions. Often these built-in functions rely on "secret" internal indexes that make the function fast. But even if so, that hack only works when your query runs `MAX()` over the entire table.

Thinking more generally, what if your "index" is derived for many objects, possibly ones that are far away from each other? Suppose for example you need to be able to efficiently calculate the average age of _all the friends_ of any `Person`. An SQL `AVG()` query will need to iterate through all the friends to calculate the average. With today's huge datasets, iterating through every element of a collection may not be an option. Since there's no SQL command to tell the database to keep an index of the average age of each `Person`'s friends, you will have to consruct and maintain this index yourself.

This is an important subtlety that affects scaling applications written using SQL databases: if what you want to index can't be indexed by a capability built-in to the database, but your dataset is too large to _not_ index the information you need, then suddenly you have "index" logic spamming your Java codebase.

In our present example, you would have to track down any code that either (a) alters the age of a `Person` (and then figure out who that `Person` is a friend of), or (b) changes any `Person`'s set of friends. But clearly the logic for maintaining a database index, which is nothing but derived information, belongs at the data layer, not the service or business layer.

=== `@OnChange` ===

With JSimpleDB, you can index virtually anything, based on any reachable information, using the `@OnChange` annotation. The `@OnChange` annotation allows you to monitor arbitrarily distant changes by specifying the reference path to the change you want to monitor.

Now maintaining an index is as simple as:
 # Detect relevant changes via `@OnChange`-annotated methods
 # Update the derived information when a change occurs

Most importantly, the code that implements #1 and #2 above all lives in one Java class.

In the example below, we monitor for changes in our set of friends and their ages, and update the average age automatically. This works no matter how the age is modified or where else those changes might be made in your codebase.
We keep all the code to maintain our custom "friends' average age" index in one place where it belongs - in the data object.

<code language="java">
    // Get my friends' average age - value is always up to date!
    public double getFriendsAverageAge() {
        return (double)this.getFriendsAgeSum() / this.getNumFriends();
    }
 
    // Keep track of how many friends I have
    @JSaneField(storageId = 104)
    abstract int getNumFriends();
    abstract void setNumFriends(int numFriends);
 
    // Keep track of the sum of my friends' ages
    @JSaneField(storageId = 105)
    abstract long getFriendsAgeSum();
    abstract void setFriendsAgeSum(long ageSum);
 
    // Notify me when any of my friend's ages changes
    @OnChange("friends.element.age")
    private boolean onFriendAgeChange(SimpleFieldChange<Person, Integer> change) {
        this.setFriendsAgeSum(this.getFriendsAgeSum() - change.getOldValue() + change.getNewValue());
    }
 
    // Notify me when a friend is added
    @OnChange("friends")
    private boolean onFriendsAdd(SetFieldAdd<Person, Person> change) {
        this.setFriendsAgeSum(this.getFriendsAgeSum() + change.getElement().getAge());
        this.setNumFriends(this.getNumFriends() + 1);
    }
 
    // Notify me when a friend is removed
    @OnChange("friends")
    private boolean onFriendsRemove(SetFieldRemove<Person, Person> change) {
        this.setFriendsAgeSum(this.getFriendsAgeSum() - change.getElement().getAge());
        this.setNumFriends(this.getNumFriends() - 1);
    }
 
    // Notify me when friends is cleared
    @OnChange("friends")
    private boolean onFriendsClear(SetFieldClear<Person> change) {
        this.setNumFriends(0);
        this.setFriendsAgeSum(0);
    }</code>

This index is maintained as efficiently as possible: we are notified only when a meaningful change occurs, and the update is incremental (constant time) and immediate.

By the way, JSimpleDB does not notify for "changes" that don't actually change anything, such as `person.setAge(21)` when the age equals `21`, or `person.getFriends().add(friend)` when `friend` is already in the set. Also, each object is only notified once about any particular change, even if the change is visible through multiple different routes through the reference path (this would necessarily involve a collection somewhere on the path).

`@OnChange` notifications are also handy for validation scenarios involving distant dependencies (see [#Validation Validation]).

==== Calculating Sizes ====

Notice in the example we are tracking the size of the `friends` set manually. Why not just use `this.getFriends().size()`?

In JSimpleDB invoking `size()` on any collection type requires an _O(n)_ time interation through the collection, which can be a slow operation.

This may seem dumb - why not just keep track of the size? There is an important reason: allowing for reduced contention in distributed databases.

Imagine a database with many distributed nodes on the network, and on each node an application is rapidly adding new objects to some `Set`. If JSimpleDB maintained a hidden `size` field with each collection, then that field would have to be updated with each insert, and therefore would be highly contended (i.e., causing a bottleneck), causing the database to be slow. Without it, however, the set elements can be added concurrently without conflict.

JSimpleDB leaves it up to you whether the size of a collection should be explicitly maintained. After all, the size of a collection is just another type of index (derived information).

*Note* Some key/value databases provide datatypes allowing writing without reading, for example incrementing a counter without reading it. This allows concurrent writes to be handled withouth conflict and would be a best-of-both-worlds solution for maintaining collection sizes. In the future, JSimpleDB will add a new integral datatype reflecting this support, falling back to the usual behavior for key/values stores that don't support it.

=== Lifecycle Notifications ===

JSimpleDB provides notifications whenever a database object is created or deleted via the `@OnCreate` and `@OnDelete` annotations:

<code language="java">
    @OnCreate 
    private void gotCreated() {
        System.out.println("Hello world");
    }
 
    @OnDelete 
    private void gotDeleted() {
        System.out.println("Goodbye world");
    }</code>

Note that `@OnCreate` is not the same event as object construction, e.g., because a deleted object can be `recreate()`d in which case `@OnCreate` will be invoked again.

== Schema Management ==

Traditional SQL databases provide no explicit support for managing schema changes. This used to be OK when you had a single application server running on a single database, and it was small enough that running a few `ALTER TABLE` statements after a restart was relatively quick.

Today, however, not only are the data sets too large for schema changes that lock an entire table, it's often not acceptable to bring down all of the application servers at the same time, even if you could upgrade them all quickly. Instead, a rolling upgrade is required, where during the upgrade period different application servers will be running different versions of the software. Therefore, at some point you are going to have two different versions of your application running on two different nodes, both reading from and writing to the same database, but expecting to see and use different schemas. This situation presents obvious challenges.

Some NoSQL databases duck this question by being "schemaless", which really means "the schema is your problem, not mine". Other databases support the notion of an object version, but leave the rest to the application developer.

An important goal of JSimpleDB is to provide a first class solution to this problem by providing explicit support to the application for schema maintenance and migration. In addition, the code for handling schema migration should live only in the data layer and not pollute the rest of the application.

This support has several aspects.

=== Schema Tracking ===

JSimpleDB databases have an explicit notion of a *schema* as well as schema *version numbers*, and you must explicitly tell JSimpleDB what schema and version number you are using before you can do anything with a database. If the schema you are intending to use conflicts with what's recorded in the database, you will get an error. JSimpleDB simply won't let you inadvertently read or write data in an incompatible way.

A schema is defined as a set of object types and the fields in those object types. Each object type and field is identified by its unique storage ID. Therefore, changes to the names of objects or fields do not constitute a schema change.

Internally, schemas are represented by `SchemaModel` objects. This object type has an XML representation which is used to serialize the schema into the database. Normally, you don't need to mess with `SchemaModel`s - they are generated for you from your annotated classes and handled automatically. But methods exist to allow you to access and introspect the current and all previously recorded database schemas if necessary.

=== Schema Verification ===

Within each JSimpleDB database is recorded the version and associated `SchemaModel` of every schema that has ever been used to write new objects into that database in the past. When a JSimpleDB database is initialized, a schema is generated from your annotated classes, but you must specify the version number of that schema, and the first thing that occurs in each new transaction is a (quick) verification that the provided schema matches the schema with that version number recorded in the database.

If there is a mismatch, an `InvalidSchemaException` exception is thrown. If the database has no record of that schema version, and you have configured JSimpleDB to allow recording new schemas, it will write the new schema into the database and proceed normally. If JSimpleDB is configured to not allow recording new schemas, an exception is thrown (more on when to enable this setting below).

=== Object Versions ===

In addition to tracking the schemas, JSimpleDB also records with each object:
 * The storage ID associated with the object's type; and
 * The version of the schema according to which the object was written
Together this information tells us what fields are part of that particular object.

So now imagine two different application servers talking to the same database, but using different schema versions. If they are both creating objects, then the database might contain objects of the same type (i.e., with the same storage ID) but having different versions and therefore containing different fields.

What happens when an object with version X is read by the application server using schema version Y? The following occurs:

 # The object is automatically upgraded (or downgraded) from schema version X to schema version Y
    * Removed fields are removed (pending step #2)
    * New fields are initialized to their default values
    * All other fields stay the same
 # Any `@OnVersionChange` methods are invoked with these parameters:
    * The old schema version
    * The new schema version
    * A `Map<Integer, Object>` containing all of the old field values indexed by storage ID

So the `@OnVersionChange` notification allows the object to handle the upgrade in a controlled manner. For example, suppose your application is at release 1.1 and uses schema version #1 which has this field containing a `Person`'s name in the form _Last, First_:

<code language="java">
    @JField(storageId = 106)
    public abstract String getName();
    public abstract void setName(String name);</code>

But in application release 1.2 you decided you needed separate last and first names, so you create schema version #2, replacing the `name` field with `lastName` and `firstName` fields. Then your release 1.2 code, with a new method to handle the schema change, might look like this:

<code language="java">
    @JField(storageId = 107)
    public abstract String getLastName();
    public abstract void setLastName(String lastName);
 
    @JField(storageId = 108)
    public abstract String getFirstName();
    public abstract void setFirstName(String firstName);
 
    @OnVersionChange(oldVersion = 1, newVersion = 2)
    private void splitNameField(Map<Integer, Object> oldValues) {
        final String name = (String)oldValues.get(106);
        final int comma = name.indexOf(',');
        this.setLastName(name.substring(0, comma).trim());
        this.setFirstName(name.substring(comma + 1).trim());
    }</code>

The `splitNameField()` method will be invoked just prior to the first field access of the `Person` object being upgraded. It ensures that the field is forward-migrated properly, and none of your other release 1.2 code needs to know anything about prior schema versions.

=== Schema Migration ===

The astue reader may notice that in a "no downtime" world, even adding the above `@OnVersionChange` handler is insufficient. That's because _backward_ migration may also occur, for example, when you have upgraded some (but not all) of your servers to release 1.2, and a yet-to-be-upgraded release 1.1 server needs to read an object written by an already-upgraded release 1.2 server.

So we see the combination of multiple nodes, no application downtime, and incremental upgrades involving incompatible schemas makes things tricky indeed.

The answer is a multi-step migration process. First, create an intermediate software release 1.1.5 containing the downward migration `@OnVersionChange` handler:

<code language="java">
    @JField(storageId = 106)
    public abstract String getName();
    public abstract void setName(String name);
 
    @OnVersionChange(oldVersion = 2, newVersion = 1)
    private void joinNameField(Map<Integer, Object> oldValues) {
        this.setName(oldValues.get(107) + ", " + oldValues.get(108));
    }</code>

This new intermediate release 1.1.5 of your software still uses the original schema version #1, but it is now prepared to handle a schema version #2 object if it encounters one. Again, this handling is contained entirely in the data object.

Now your upgrade rolls out in two phases:

 # Upgrade all machines from version 1.1 to 1.1.5
 # Upgrade all machines from version 1.1.5 to 1.2

Voil√† - an incremental, multi-node rolling application upgrade across releases using incompatible schema versions and with no downtime.

During phase 1, all objects stay at schema version #1. During phase 2, objects are upgraded and downgraded as necessary as different servers access them. Once phase 2 is complete, all future object accesses will use schema version #2, upgrading old version #1 objects on demand over time. Or, you can run a one-time scan that upgrades objects using `JObject.upgrade()`.

Note that release 1.2 of your software will need to configure JSimpleDB to allow the addition of new schemas. Once phase 2 is complete, this setting can be turned back off.

== Validation ==

JSimpleDB supports automatic incremental verification of JSR 303 validation constraints. By "incremental" we mean only those objects containing a field that has actually changed are (re)validated. Each time an object field is changed, the object is added to an internal validation queue (if not already on it). The validation queue is processed automatically on `commit()`, and if validation fails, a `ValidationException` is thrown.

What is described above is the same as supplied by e.g., JPA. However, JSimpleDB also adds a few additional useful features.

 * You can manually add any object to the validation queue by invoking `revalidate()` on that object.
 * You can supply custom validation logic by annotating a method with `@Validate`. All such methods will be invoked when the object is validated.
 * Combining `@Validate` with `@OnChange` allows you to validate complex, multi-object constraints (see below)

Note that JSimpleDB validates on a per-object basis. Therefore, the `@Valid` constraint, which causes validation to recurse through reference(s) to other objects, is redundant and rarely needed.

=== Configuring Validation ===

When creating a new JSimpleDB transaction, you specify the `ValidationMode` for the transaction. The default is `AUTOMATIC` which gives the behavior described above. The available options are:
 * `DISABLED` - no validation will be performed, even if you invoke `JTransaction.validate()` explicitly
 * `MANUAL` - validation is only performed when you invoke `JTransaction.validate()` explicitly; changes to fields with JSR 303 annotations do _not_ enqueue the object for validation
 * `AUTOMATIC` - validation is performed when you invoke `JTransaction.validate()` explicitly, and automatically on `commit()`; changes to fields with JSR 303 annotations automatically enqueue the object for validation

=== Complex Validation ===

Although `javax.validation.constraints` provides many handy validation constraints, there are often cases that require validation of more complex constraints that depend on more than one field, or even multiple objects at the same time.

For example, suppose each `Person` may have both `friends` and `enemies` and you have a constraint that says nobody can be both a friend and an enemy. This kind of constraint is difficult to handle efficiently with traditional ORM solutions.

With JSimpleDB, this is easy to do by following these steps:
 # Add a `@Validate`-annotated method that checks the constraint
 # Detect relevant changes via `@OnChange` and enqueue for validation

Here's an example:

<code language="java">
    @OnChange("friends")
    private boolean onFriendsChange(SetFieldChange<Person> change) {
        this.revalidate();
    }
 
    @OnChange("enemies")
    private boolean onEnemiesChange(SetFieldChange<Person> change) {
        this.revalidate();
    }
 
    @Validate 
    private void checkForFrenemies() {
        if (!NavigableSets.intersection(this.getFriends(), this.getEnemies()).isEmpty())
            throw new ValidationException(this, "we don't allow frenemies");
    }</code>

== Core Database Model ==

JSimpleDB is normally used and configured via annotated Java classes, but this is not actually required. The Java model/annotation layer sits on top of the *core database* layer, which we describe here.

The core database layer has the following notions:
 * *Schema*
  * Has a *version number* (positive integer)
  * Includes a collection of *object types*
 * *Object Type*
  * Identified by a unique storage ID
  * Includes a collection of *fields*
 * *Objects*
  * Objects have an associated object type
  * Objects have a schema version number
 * *Fields*
  * Is either *simple* or *complex*
  * Has a unique storage ID
 * *Simple Fields*
  * Holds an atomic, sortable value like `int` or `Date`
  * Primitive types are supported
  * Non-primitive types may be null
  * May optionally be *indexed*.
 * *Reference Fields*
  * A special type of simple field that holds a reference to an object
  * Always indexed
 * *Complex Fields*
  * Sets, Lists, and Maps
  * Complex fields have one or more *sub-fields*, which are always simple fields
  * A complex field may not be itself indexed, but any of its simple sub-field(s) may be
  * Bub-fields may have primitive type; if so, `IllegalArgumentException` is thrown if you try to add `null`

All objects and fields have a unique *storage ID*. However, the same field may be contained in multiple object types (this is how Java sub-types are handled).

Any storage ID that is used by two or more schema versions must be used consistently. This means the storage ID of an object type must always be associated with an object type, and the storage ID of a field must always be associated with a field having the same type (including sub-fields if complex). There are a few exceptions however:
 * Simple fields may change whether they are indexed between schema versions
 * Reference fields may change their `DeleteAction` between schema versions

If a field is changed between schema versions, the field will behave according to the schema version of the object containing it. So for example when a field's indexing is turned on or off between schemas, an object containing that field will appear in the index only when the schema associated with the object's version has the field indexed.

