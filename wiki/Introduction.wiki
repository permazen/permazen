#summary Introduction to JSimpleDB
#labels Featured

== Introduction ==

JSimpleDB is designed to make powerful persistence easy for Java programmers. It does this by relegating the database to the simplest role possible--storing data as key/value pairs--and reimplementing and enhancing all of the usual database supporting features, such as indexes and notifications, in a Java-centric way.

<wiki:toc max_depth="5"/>

== Quick Example ==

Sometimes code is worth a thousand words, so here is some code:
<code language="java">
@JSimpleClass(storageId = 100)
public abstract class Person implements JObject {
 
    // My age
    @JField(storageId = 101)
    public abstract int getAge();
    public abstract void setAge(int age);
 
    // My friends
    @JSetField(storageId = 102, element = @JField(storageId = 103))
    public abstract Set<Person> getFriends();
}</code>

Of note:
 * We are defining a persistent database object `Person` containing two fields:
   * An `int` field named `age` of type `int`
   * A `Set` field named `friends` with element type `Person`
 * The getter methods for `age` and `friends` may be declared `abstract`
   * JSimpleDB will override these methods in an auto-generated subclass at runtime
   * The generated subclass will implement the `JObject` interface
 * There is no setter method for the `friends` set
   * The set will always exist
 * Every Java model class and field (including sub-fields, like the `element` sub-field of `friends`) has a unique *storage ID*
   * Internally, objects and fields are identified by storage ID, not name
   * Storage IDs are used to access (possibly removed) old fields after a schema change (more on that later)

== Accessing Data ==

=== Object Lifecycle ===

So far so good. But how do you create a `Person`? Invoke `create()` on a `JTransaction` object, e.g.:

<code language="java">
    // Create a Person
    public static Person create() {
        return JTransaction.getCurrent().create(Person.class);
    }</code>

`JTransaction` represents a JSimpleDB transaction. The `JTransaction` associated with the current thread is available from the static method `JTransaction.getCurrent()`.

All state associated with JSimpleDB objects lives in the `JTransaction`. The model objects themselves are stateless, except for their internal object ID. When you access a field of a model object, you are implicitly accessing that field's value in the `JTransaction` associated with the current thread. If there is no such `JTransaction`, an `IllegalStateException` is thrown.

Java model objects do not change from transaction to transaction like with JPA. You will get, and can use, the same `Person` object over and over again in multiple transactions. Of course, the person's fields may have different values in different transactions.

If you try to access a `Person` object in a new transaction when that `Person` has been deleted in some earlier committed transaction, you get a `DeletedObjectException`. You can check for this condition via `JObject.exists()`, and (if need be) recreate the object (with all fields reinitialized) via `JObject.recreate()`.

To get all `Person`s:

<code language="java">
    // Get all people
    public static Set<Person> getAll() {
        return JTransaction.getCurrent().getAll(Person.class);
    }</code>

How do you delete a `Person`?

<code language="java">
    person.delete();</code>

Alternately, you can say:

<code language="java">
    JTransaction.getCurrent().delete(person);</code>

The two are equivalent.

The `exists()`, `delete()`, and `recreate()` methods are part of the `JObject` interface, which all generated model subclasses implement. Your classes don't have to to be declared to implement `JObject`, but life is easier if they are.

=== Delete Cascade ===

JSimpleDB provides an equivalent of SQL `ON DELETE ...` for reference fields. This applies to the situation where an object is deleted, but that object still has one or more other objects referencing it.

You have four choices, represented by the constants in the `DeleteAction` enum class:

 * `EXCEPTION` - Disallow deletion of such an object; instead, throw `ReferencedObjectException`.
 * `UNREFERENCE` - Set all references to the object to null (in the case of simple reference fields) or remove the corresponding collection entry (in the case of sets and lists) or key/value entry (in the case of maps).
 * `DELETE` - Delete all objects referring to the deleted object, repeating recursively as necessary.
 * `NOTHING` - Do nothing; subsequent attempts to dereference the deleted object will result in a `DeletedObjectException`.

The default value is `EXCEPTION`.

You can be guaranteed to never see any `DeletedObjectException`s if you adhere to the following:
 # Don't use `DeleteAction.NOTHING` for object references
 # Always check `exists()` before using a Java model object that has been brought in from outside the transaction

=== Indexes ===

Given the above `Person` class, if you wanted to calculate whether any `Person` having a specific age existed, you would have to write this code:
<code language="java">
    public boolean existsPersonOfAge(int age) {
        for (Person person : Person.getAll()) {
            if (person.getAge() == age)
                return true;
        }
        return false;
    }</code>

Having to write that code is a _good_ thing: JSimpleDB is exposing the underlying performance reality and forcing you to confront the fact that the cost of calculating this function is an iteration over every `Person` in the database. With large database, that could be impractical.

This is of course the perfect situation for an *index* on the `age` field. Here we add `indexed = true` to the `@JField` annotation:

<code language="java">
    // My age - now indexed!
    @JField(storageId = 101, indexed = true)
    public abstract int getAge();
    public abstract void setAge(int age);</code>

To read that index, you just delcare and annotate with `@IndexQuery` a method that reads it:

<code language="java">
    @IndexQuery("age")
    public abstract NavigableMap<Integer, NavigableSet<Person>> queryPersonAges();</code>

In JSimpleDB, an index is a mapping from field value to the set of objects having that value in the field.

Now we can rewrite our `existsPersonOfAge()` method:

<code language="java">
    public boolean existsPersonOfAge(int age) {
        return this.queryPersonAges().containsKey(age);
    }</code>

Lots of other possibilities exist as well. For example:

<code language="java">
    public int getMaximumAge() {
        NavigableMap<Integer, NavigableSet<Person>> index = this.queryPersonAges();
        return !index.isEmpty() ? index.lastKey() : -1;
    }</code>

The astute reader may notice that `existsPersonOfAge()` and `getMaximumAge()` should really be a static methods, because there's nothing about them that is specific to one `Person`. And that is correct; however, you can't override static methods, so the method has to be an instance method for JSimpleDB to generate a subclass implementation. If you really wanted a static method, you could do this:

<code language="java">
    @SuppressWarnings("unchecked")
    public static boolean getMaximumAge() {
        NavigableMap<Integer, NavigableSet<Person>> index
          = (NavigableMap<Integer, NavigableSet<Person>>)JTransaction.getCurrent().querySimpleField(101);
        return JTransaction.getCurrent().querySimpleField(101).containsKey(age);
    }</code>

but that's rather ugly. A cleaner option is to define a singleton class `Indexes` containing all of your index query methods.

==== Complex Field Indexes ====

You can also index the `element` sub-field of a `Set` or `List`, or the `key` or `value` sub-fields of a `Map`. For example:

<code language="java">
@JSimpleClass(storageId = 200)
public abstract class Student implements JObject {

    @JSetField(storageId = 201,
      element = @JField(storageId = 202, indexed = true)
    public abstract Set<LectureClass> getLectureClasses();

    @IndexQuery("lectureClasses.element")
    public abstract NavigableMap<LectureClass, NavigableSet<Student>> queryStudentsByLectureClass();

    @JListField(storageId = 203,
      element = @JField(storageId = 204, indexed = true)
    public abstract List<Teacher> getTeacherRankings();

    @IndexQuery("teacherRankings.element")
    public abstract NavigableMap<Teacher, NavigableSet<Student>> queryStudentsByRankedTeacher();

    @JMapField(storageId = 205,
      key = @JField(storageId = 206)
      value = @JField(storageId = 207, indexed = true)
    public abstract Map<Test, Float> getTestScores();

    @IndexQuery("testScores.key")
    public abstract NavigableMap<Test, NavigableSet<Student>> queryStudentsByTest();

    @IndexQuery("testScores.value")
    public abstract NavigableMap<Float, NavigableSet<Student>> queryStudentsByTestScore();
}</code>

==== Complex Field Indexes (Advanced) ====

In the case of `List` and `Map`, you also have the option of returning not just the set of objects having the indexed value, but also their position in the list (for `List`) or corresponding value or key (for `Map`):

<code language="java">
@JSimpleClass(storageId = 200)
public abstract class Student implements JObject {

    @IndexQuery("teacherRankings.element")
    public abstract NavigableMap<Teacher, NavigableSet<ListIndexEntry<Student>>> queryStudentsByRankedTeacherWithRank();

    @IndexQuery("testScores.key")
    public abstract NavigableMap<Test, NavigableSet<MapKeyIndexEntry<Student, Float>>>
      queryStudentsByTestWithScore();

    @IndexQuery("testScores.value")
    public abstract NavigableMap<Float, NavigableSet<MapValueIndexEntry<Student, Test>>>
      queryStudentsByTestScoreWithTest();</code>

So while `queryStudentsByRankedTeacher().get(teacher)` returns all students who ranked `teacher`, `queryStudentsByRankedTeacherWithRank().get(teacher)` returns all students who ranked `teacher` along with the teacher's rank.

Similarly, while `queryStudentsByTest().get(test)` returns all students who took `test`, `queryStudentsByTestWithScore().get(test)` returns all students who took `test` along with their scores on the test; and
, while `queryStudentsByTestScore().get(95.0f)` returns all students who got a `95` on some test, `queryStudentsByTestScoreWithTest().get(95.0f)` returns all students who got a `95` on some test along with the test.

=== Joins ===

Now suppose the question you need to frequently answer is not whether any person exists of a specific age, but whether a specifc `Person` has any _friend_ of a specific age.

We just need to intersect the set of that `Person`'s friends with the set of people of a specified age. This is the equivalent of an SQL `INNER JOIN`.

First we need to declare `friends` as a `NavigableSet` (which is what it really is):

<code language="java">
    // My friends
    @JSetField(storageId = 102, element = @JField(storageId = 103))
    public abstract NavigableSet<Person> getFriends();</code>

Then we just do the "join" via set intersection:

<code language="java">
    public boolean existsFriendOfAge(int age) {
        NavigableSet<Person> peopleOfAge = this.queryPersonAges().get(age);
        return peopleOfAge != null && !NavigableSets.intersect(peopleOfAge, this.getFriends()).isEmpty();
    }</code>

The `NavigableSets` utility class provides efficient methods for set intersection, union, and difference. Of course, the sets must have comparable elements, and in particular, a consistent sort order for those elements, which is what allows the intersection operation to be efficient. JSimpleDB provides (and verifies) this consistent ordering for you.

=== Reference Inversion ===

In JSimpleDB reference fields, including sub-fields of a collection field, are always indexed, so it's easy to ask what objects reference any other object:

<code language="java">
    @IndexQuery("friends.element")
    abstract NavigableMap<Person, NavigableSet<Person>> queryFriends();
 
    // Who considers me a friend?
    public Set<Person> whoConsidersMeAFriend() {
        return this.queryFriends().get(this);
    }</code>

Alternatively, you can invert references in an ad hoc manner by providing a *reference path* to `invertReferencePath()`:

<code language="java">
    // Who considers me a friend?
    public Set<Person> whoConsidersMeAFriend() {
        return JTransaction.getCurrent().invertReferencePath(Person.class,
          "friend", Collections.singleton(this));
    }
 
    // Who considers any of my friends a friend of a friend?
    public Set<Person> whoConsidersAnyOfMyFriendsAFriend() {
        return JTransaction.getCurrent().invertReferencePath(Person.class,
          "friend.friend", this.getFriends());
    }</code>

== Detecting Changes ==

=== Custom Indexes and `@OnChange` ===

An index is just a special case of _derived information_ that is kept up to date automatically for you by the database. With JSimpleDB you can easily build your own indexes based on any derived information. Normally the hard part bout doing this is tracking down all the places in your code that could possibly modify the information from which your index is derived. JSimpleDB makes that task much easier.

With traditional databases, it's easy as long as the information is all contained in one object: then you add intercept/update code into the setter methods of all the fields that affect the derived information. This extra code serves as a trap for the change whereby it then updates the derived information.

Or if you're lucky, your derived information matches an SQL built-in aggregate function like `MAX()` for which SQL databases often have "secret" indexes that make the function fast. But that hack only works if your query runs `MAX()` over the entire table.

What if your "index" is derived for many objects, possibly ones that are far away? Suppose for example you need to be able to efficiently calculate the average age of _all the friends_ of any `Person`. An SQL `AVG()` query will need to iterate through all the friends to calculate the average. With today's huge datasets iterating through every element of a collection may not be an option. Since there's no SQL command to tell the database to index the average age of each `Person`'s friends, you will have to consruct and maintain this index yourself.

This is an important subtlety that affects scaling applications written using SQL databases: if what you want to index can't be done by the index capability built-in to the database, but your dataset is too large to _not_ index the information you need, then suddenly you have "index" logic spamming your Java codebase. In this example, you will have to track down any code that either (a) alters the age of a `Person` (and then figure out who that `Person` is a friend of), or (b) changes any `Person`'s set of friends. Clearly, the logic for maintaining a database index, which is nothing but derived information, belongs at the data layer, not the service or business layer.

With JSimpleDB, you can index virtually anything, based on arbitrarily distant dependencies, using the `@OnChange` annotation. This lets you keep all the code to maintain your custom "friends' average age" index in one place where it belongs - in the data object.

In this example, we monitor for changes in our set of friends and their ages, and update the average automatically. This works no matter how the age is modified or where else those changes might be made in your codebase:

<code language="java">
    // Get my friends' average age - value is always up to date!
    public double getFriendsAverageAge() {
        return (double)this.getFriendsAgeSum() / this.getNumFriends();
    }
 
    // Secretly keep track of how many friends I have
    @JSaneField(storageId = 104)
    abstract int getNumFriends();
    abstract void setNumFriends(int numFriends);
 
    // Secretly keep track of the sum of my friends' ages
    @JSaneField(storageId = 105)
    abstract long getFriendsAgeSum();
    abstract void setFriendsAgeSum(long ageSum);
 
    // Notify me when any of my friend's ages changes and update age sum
    @OnChange("friends.element.age")
    private boolean onFriendAgeChange(SimpleFieldChange<Person, Integer> change) {
        this.setFriendsAgeSum(this.getFriendsAgeSum() - change.getOldValue() + change.getNewValue());
    }
 
    // Notify me when my set of friends changes and update age sum and friend count
    @OnChange("friends")
    private boolean onFriendsChange(SetFieldChange<Person, Person> change) {
        if (change instanceof SetFieldAdd) {
            this.setFriendsAgeSum(this.getFriendsAgeSum() + ((SetFieldAdd)change).getElement().getAge());
            this.setNumFriends(this.getNumFriends() + 1);
        } else if (change instanceof SetFieldRemove) {
            this.setFriendsAgeSum(this.getFriendsAgeSum() - ((SetFieldAdd)change).getElement().getAge());
            this.setNumFriends(this.getNumFriends() - 1);
        } else {
            assert change instanceof SetFieldClear;
            this.setNumFriends(0);
            this.setFriendsAgeSum(0);
        }
    }</code>
This index is maintained as efficiently as possible: we are notified only when a meaningful change occurs, and the update is incremental (constant time) and immediate.

By the way, JSimpleDB does not notify for "changes" that don't actually change anything, such as `person.setAge(21)` when the age is already `21`, or `person.getFriends().add(friend)` when `friend` is already in the set.

`@OnChange` notifications are also handy for validation scenarios involving distant dependencies (see [#Validation]).

==== Calculating Sizes ====

Notice in the example we are tracking the size of the `friends` set manually. Why not just use `this.getFriends().size()`?

In JSimpleDB invoking `size()` on any collection type requires an _O(n)_ time interation through the collection. Huh? This seems dumb, why not just keep track of the size?

There is an important reason: allowing for reduced contention in distributed databases.

Imagine a database with 20 distributed nodes on the network, and on each node an application is rapidly adding new objects to some `Set`. If JSimpleDB maintained a hidden `size` field with each collection, then that field would have to be updated with each insert, and therefore would be highly contended and cause the database to be slow. Without it, however, the set elements can be added concurrently without conflict.

JSimpleDB leaves it up to you whether the size of a collection should be explicitly maintained. After all, the size of a collection is just another type of index (derived information).

Some key/value databases provide datatypes allowing writing without reading, for example incrementing a counter without reading it. This allows concurrent writes to be handled withouth conflict and would be a best-of-both-worlds solution for maintaining collection sizes. In the future, JSimpleDB may add a new integral datatype reflecting this support, falling back to the usual behavior for key/values stores that don't support it.

=== Lifecycle Notifications ===

JSimpleDB provides notifications whenever a database object is created or deleted via the `@OnCreate` and `@OnDelete` annotations:

<code language="java">
    @OnCreate 
    private void gotCreated() {
        System.out.println("Hello world");
    }
 
    @OnDelete 
    private void gotDeleted() {
        System.out.println("Goodbye world");
    }</code>

Note that `@OnCreate` is not the same event as object construction, e.g., because a deleted object can be `recreate()`d in which case `@OnCreate` will be invoked again.

== Schema Management ==

=== Schema Changes ===

Traditional SQL databases provide no explicit support for managing schema changes. This used to be OK when you had a single database, and it was small enough that running a few `ALTER TABLE` statements was relatively quick.

Today, however, not only are the data sets too large for schema changes that lock an entire table, it's often not acceptable to bring down the application servers all at the same time, even if you can upgrade them quickly. Instead, a rolling upgrade is required where for some period different application servers may be running different versions of the software. Therefore, at some point you are going to have two different versions of your application running on two different nodes, both reading from and writing to the same database, but expecting to see and use different schemas. This situation presents obvious challenges.

Some NoSQL databases duck this question by being "schemaless", which really means "the schema is your problem, not mine". Other databases support the notion of an object version, but leave the rest to the application developer.

An important goal of JSimpleDB is to provide a first class solution to this problem by providing explicit support to the application for schema maintenance and migration.

This support has several aspects.

==== Schema Tracking ====

JSimpleDB databases have an explicit notion of a *schema* as well as schema *version numbers*, and you must explicitly tell JSimpleDB what schema and version number you are using before you can do anything with a database. If the schema you are intending to use conflicts with what's in the database, you will get an error - JSimpleDB won't let you write data incompatibly.

A schema is defined as a set of objects and the fields in those objects. Each object and field is identified only by its storage ID, which must be unique in that schema. Therefore, changes to the names of objects or fields do not constitute a schema change.

Internally, schemas are represented by `SchemaModel` objects. This object type has an XML representation which is used to record the schema in the database. Normally, you don't need to mess with `SchemaModel`s - they are generated for you from your annotated classes and handled automatically.

==== Schema Verification ====

Within each JSimpleDB database is recorded the version and associated `SchemaModel` of every schema that has ever been used with the database in the past. When a JSimpleDB database is initialized, a schema is generated from your annotated classes, but you must specify the version number of that schema, and the first thing that occurs in each new transaction is a (quick) verification that the provided schema matches one of the schemas recorded in the database.

If not, and you have configured JSimpleDB to allow recording new schemas, it will record the new schema and proceed normally. If JSimpleDB is configured to not allow recording new schemas, an exception is thrown. More on when to enable this setting later.

==== Object Versions ====

In addition to tracking the schemas, JSimpleDB also records with each object:
 * The storage ID associated with the object's type; and
 * The version of the schema under which the object was written.
Together this information tells us what fields are part of that object.

So now imagine two different application servers talking to the same database but using different schema versions. If they are both creating objects, then the database might contain objects of the same type (i.e., with the same storage ID) but having different versions and therefore containing different fields.

What happens when an object with version X is read by the application server using schema version Y?

 # The object is automatically upgraded from schema version X to schema version Y
    * Removed fields are removed (pending step #2)
    * New fields are initialized to their default values
    * All other fields stay the same
 # Any `@OnVersionChange` methods are invoked with these parameters:
    * The old schema version
    * The new schema version
    * A `Map<Integer, Object>` of all old field values indexed by storage ID

So the `@OnVersionChange` notification allows the object to handle the upgrade in a controlled manner. For example, suppose your application is at release 1.1 and uses schema version #1 which has this field containing names in the form _Last, First_:

<code language="java">
    @JField(storageId = 106)
    public abstract String getName();
    public abstract void setName(String name);</code>

But in application release 1.2 you decided you needed separate last and first names, so you create schema version #2 with separate last and first name fields. Then your release 1.2 code that handles the schema change automatically might look like this:

<code language="java">
    @JField(storageId = 107)
    public abstract String getLastName();
    public abstract void setLastName(String lastName);
 
    @JField(storageId = 108)
    public abstract String getFirstName();
    public abstract void setFirstName(String firstName);
 
    @OnVersionChange(oldVersion = 1, newVersion = 2)
    private void splitNameField(Map<Integer, Object> oldValues) {
        final String name = (String)oldValues.get(106);
        final int comma = name.indexOf(',');
        this.setLastName(name.substring(0, comma).trim());
        this.setFirstName(name.substring(comma + 1).trim());
    }</code>

The `splitNameField()` method will be invoked just prior to the first field access of the `Person` object being upgraded. You have ensured that the field is forward-migrated properly, and none of your other release 1.2 code needs to know about prior schema versions.

==== Schema Migration ====

The astue reader may notice that in a "no downtime" world, even adding the above `@OnVersionChange` handler is insufficient. That's because _backward_ migration may also occur, for example, when you have upgraded some (but not all) of your servers to release 1.2, and a release 1.1 server needs to read an object written by release 1.2 server.

So we see the combination of multiple nodes, no application downtime, and incremental upgrades involving incompatible schemas makes things tricky.

The answer is a multi-step migration process. First, create an intermediate software release 1.1.5 containing the downward migration `@OnVersionChange` handler:

<code language="java">
    @JField(storageId = 106)
    public abstract String getName();
    public abstract void setName(String name);
 
    @OnVersionChange(oldVersion = 2, newVersion = 1)
    private void joinNameField(Map<Integer, Object> oldValues) {
        this.setName(oldValues.get(107) + ", " + oldValues.get(108));
    }</code>

This new intermediate release 1.1.5 of your software still uses the original schema version #1, but it is prepared to handle schema version #2 if encountered.

Now your upgrade rolls out in two phases:

 # Upgrade all machines from version 1.1 to 1.1.5
 # Upgrade all machines from version 1.1.5 to 1.2

Voil√† - an incremental, multi-node rolling application upgrade across releases using incompatible schema versions with no downtime.

Note that release 1.2 of your software will need to configure JSimpleDB to allow the addition of new schemas. Once at least one 1.2 application server has committed a transaction, the new schema #2 will be recorded in the database, and this setting can be turned back off if desired.

== Validation ==

JSimpleDB supports automatic incremental verification of JSR 303 validation constraints. By "incremental" we mean only those objects containing a field that has actually changed are (re)validated. Each time an object field is changed, the object is added to an internal validation queue (if not already on it). The validation queue is processed automatically on `commit()`, and if validation fails, a `ValidationException` is thrown.

What is described above is the same as supplied by e.g., JPA. However, JSimpleDB also adds a few additional useful features.

* You can manually add any object to the validation queue by invoking `JObject.revalidate()` on that object.
* You can supply custom validation logic by annotating a method with `@Validate`: all such methods will be invoked when the object is validated.
* Combining `@Validate` with `@OnChange` allows you to validate complex, mult-object constraints (see below)

Note that JSimpleDB validates on a per-object basis. Therefore, the `@Valid` constraint, which causes validation to recurse through reference(s) to other objects, is redundant and rarely needed.

=== Configuring Validation ===

When creating a new JSimpleDB transaction, you specify the `ValidationMode` for the transaction. The default is `AUTOMATIC` which gives the behavior described above. The available options are:
 * `DISABLED` - no validation will be performed, even if you invoke `JTransaction.validate()` explicitly
 * `MANUAL` - validation is only performed when you invoke `JTransaction.validate()` explicitly
 * `AUTOMATIC` - validation is performed when you invoke `JTransaction.validate()` explicitly and on `commit()`

=== Complex Validation ===

Although `javax.validation.constraints` provides many handy validation constraints, there are often cases that require validation of more complex constraints that depend on multiple objects at once. For example, suppose each `Person` may have both `friends` and `enemies` and you may have a constraint that says nobody can be both a friend and an enemy. This kind of constraint is difficult to handle efficiently with traditional ORM solutions.

With JSimpleDB, this is easy to do by following these steps:
 # Add a `@Validate`-annotated method that checks the constraint
 # Detect relevant changes via `@OnChange` and enqueue for validation

<code language="java">
    @OnChange("friends")
    private boolean onFriendsChange(SetFieldChange<Person, Person> change) {
        this.revalidate();
    }
 
    @OnChange("enemies")
    private boolean onEnemiesChange(SetFieldChange<Person, Person> change) {
        this.revalidate();
    }
 
    @Validate 
    private void checkForFrenemies() {
        if (!NavigableSets.intersection(this.getFriends(), this.getEnemies()).isEmpty())
            throw new ValidationException(this, "we don't allow frenemies");
    }</code>

== Core Database Model ==

JSimpleDB is normally used and configured via annotated Java classes, but this is not actually required. The Java model/annotation layer sits on top of the *core database* layer, which we describe here.

The core database layer has the following notions:
 * *Schema*
    - Has a *version number* (positive integer)
    - Includes a collection of *object types*
 * *Object Type*
    - Identified by a unique storage ID
    - Includes a collection of *fields*
 * *Objects*
   * Objects have an associated object type
   * Objects have a schema version number
 * *Fields*
   * Is either *simple* or *complex*
   * Has a unique storage ID
 * *Simple Fields*
   * Holds an atomic, sortable value like `int` or `Date`
   * Primitive types are supported
   * Non-primitive types may be null
   * May optionally be *indexed*.
 * *Reference Fields*
   * A special type of simple field that holds a reference to an object
   * Always indexed
 * *Complex Fields*
   * Sets, Lists, and Maps
   * Complex fields have one or more *sub-fields*, which are always simple fields
   * A complex field may not be itself indexed, but any of its simple sub-field(s) may be
   * Bub-fields may have primitive type; if so, `IllegalArgumentException` is thrown if you try to add `null`

All objects and fields have a unique *storage ID*. However, the same field may be contained in multiple object types (this is how Java sub-types are handled).

Any storage ID that is used by two or more schema versions must be used consistently. This means the storage ID of an object type must always be associated with an object type, and the storage ID of a field must always be associated with a field having the same type (including sub-fields if complex). There are a few exceptions however:
 * Simple fields may change whether they are indexed between schema versions
 * Reference fields may change their `DeleteAction` between schema versions

